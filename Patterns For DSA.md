sure, here it is without timestamps and formatted for markdown:

---

## Prefix Sum
**prefix sum** is an array where each element at index i is the sum of elements from the original array from index 0 to i. 

### example:
array: [1, 2, 3, 4]
prefix sum: [1, 3, 6, 10]

---

## Two Pointer
**two pointer** technique involves using two pointers to iterate through the array/list to find a solution.

### example:
array: [1, 2, 3, 4, 5], target: 6
pointers: start at (1, 5) -> move to (2, 4)

---

## Sliding Window
**sliding window** technique involves a window that slides over the array to find a solution, often used to find subarrays of a given size.

### example:
array: [1, 3, -1, 3, 5, 3, 6, 7], k = 3
windows: [1, 3, -1], [3, -1, 3], ...

---

## Fast & Slow Pointer
**fast & slow pointer** technique involves two pointers that move at different speeds to detect cycles or find the midpoint.

### example:
linked list: 1 -> 2 -> 3 -> 4 -> 5
fast moves 2 steps, slow moves 1 step

---

## Linked List In-Place Reversal
**linked list in-place reversal** involves reversing the linked list by changing the pointers of the nodes.

### example:
list: 1 -> 2 -> 3 -> 4 -> 5
reversed: 5 -> 4 -> 3 -> 2 -> 1

---

## Monotonic Stack
**monotonic stack** is a stack where the elements are ordered monotonically (either increasing or decreasing).

### example:
array: [2, 1, 5, 6, 2, 3]
stack: [2], [1], [5]...

---

## Top 'k' Elements
**top 'k' elements** involves finding the top k largest (or smallest) elements in an array.

### example:
array: [3, 2, 1, 5, 6, 4], k = 2
top k: [5, 6]

---

## Quick Select
**quick select** is a selection algorithm to find the kth smallest (or largest) element in an unsorted array.

### example:
array: [3, 2, 1, 5, 6, 4], k = 2
result: 5 (2nd largest)

---

## Overlapping Intervals
**overlapping intervals** involves merging or handling intervals that overlap.

### example:
intervals: [[1, 3], [2, 6], [8, 10], [15, 18]]
merged: [[1, 6], [8, 10], [15, 18]]

---
